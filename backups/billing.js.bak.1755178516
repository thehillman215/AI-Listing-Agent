# backup first
mkdir -p backups
cp src/billing.js backups/billing.js.bak.$(date +%s) 2>/dev/null || true

# overwrite with a single, clean version (includes reconcileSession once)
cat > src/billing.js <<'JS'
import Stripe from "stripe";
import { CREDIT_PACKS, SUCCESS_URL, CANCEL_URL } from "./config.js";
import { getDb, addCredits, recordBillingEvent } from "./db.js";

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || "", { apiVersion: "2024-06-20" });

export async function createCheckoutSession({ email, pack }) {
  const cfg = CREDIT_PACKS[pack];
  if (!cfg || !cfg.price) throw new Error("Unknown or unconfigured pack");
  const session = await stripe.checkout.sessions.create({
    mode: "payment",
    payment_method_types: ["card"],
    line_items: [{ price: cfg.price, quantity: 1 }],
    success_url: SUCCESS_URL + "&session_id={CHECKOUT_SESSION_ID}",
    cancel_url: CANCEL_URL,
    customer_email: email || undefined,
    metadata: { pack, credits: String(cfg.credits) }
  });
  return session.url;
}

export async function handleWebhook(rawBody, signature) {
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET;
  let event;
  try {
    event = stripe.webhooks.constructEvent(rawBody, signature, endpointSecret);
  } catch (err) {
    console.error("Webhook signature verification failed:", err.message);
    throw err;
  }

  if (event.type === "checkout.session.completed") {
    const session = event.data.object;
    let email = session.customer_details?.email || session.customer_email || null;
    let credits = Number(session.metadata?.credits || 0);
    let priceId = null;

    try {
      const retrieved = await stripe.checkout.sessions.retrieve(session.id, { expand: ["line_items.data.price"] });
      priceId = retrieved?.line_items?.data?.[0]?.price?.id || null;
    } catch {}

    if (email && credits > 0) {
      addCredits(email, credits);
      recordBillingEvent({ email, credits_added: credits, stripe_checkout_id: session.id, stripe_price_id: priceId });
      console.log(`Added ${credits} credits to ${email}`);
    } else {
      console.warn("Missing email or credits on checkout.session.completed");
    }
  }

  return { received: true };
}

/**
 * Reconcile a completed Checkout Session on redirect if the webhook was delayed.
 * Requires the user to be logged in (so we know which email to credit).
 * Idempotent when combined with a UNIQUE index on billing_events(stripe_checkout_id).
 */
export async function reconcileSession({ session_id, email }) {
  const db = getDb();

  // Already processed? (webhook probably got it)
  const exists = db.prepare("select 1 from billing_events where stripe_checkout_id=?").get(session_id);
  if (exists) return { reconciled: false, reason: "already_recorded" };

  // Fetch the real session from Stripe
  const s = await stripe.checkout.sessions.retrieve(session_id, { expand: ["line_items.data.price"] });
  if (s.payment_status !== "paid") return { reconciled: false, reason: "not_paid" };

  // We stored credits in metadata when creating the session
  const credits = Number(s.metadata?.credits || 0);
  const priceId = s?.line_items?.data?.[0]?.price?.id || null;
  const sessionEmail = s.customer_details?.email || s.customer_email || null;

  // Only credit if emails match the logged-in user
  if (!credits || !sessionEmail || sessionEmail !== email) {
    return { reconciled: false, reason: "email_or_credits_missing" };
  }

  // Credit + record (same as webhook path)
  addCredits(email, credits);
  recordBillingEvent({ email, credits_added: credits, stripe_checkout_id: s.id, stripe_price_id: priceId });

  return { reconciled: true, credits };
}
JS
